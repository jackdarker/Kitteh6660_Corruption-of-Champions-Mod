From 4bc43fcbc564d8af288b39d9d39737901f8a3ed9 Mon Sep 17 00:00:00 2001
From: Jack Darker <JackDarker@freenet.de>
Date: Sun, 23 Jun 2019 11:08:32 +0200
Subject: [PATCH 3/6] added dngmapperinfo

---
 classes/classes/Scenes/Dungeons/BeeHive.as    |  20 ++-
 .../classes/Scenes/Dungeons/DngDirection.as   |  64 ++++----
 classes/classes/Scenes/Dungeons/DngFloor.as   |   3 +
 classes/classes/Scenes/Dungeons/DngMapper.as  | 138 ++++++++++++++++--
 .../classes/Scenes/Dungeons/DngMapperInfo.as  |  24 +++
 classes/classes/Scenes/Dungeons/DngRoom.as    |  65 +++++++--
 .../Scenes/Dungeons/DungeonAbstractContent.as |  23 ++-
 7 files changed, 265 insertions(+), 72 deletions(-)
 create mode 100644 classes/classes/Scenes/Dungeons/DngMapperInfo.as

diff --git a/classes/classes/Scenes/Dungeons/BeeHive.as b/classes/classes/Scenes/Dungeons/BeeHive.as
index 2e1ec1265..cfa3151bb 100644
--- a/classes/classes/Scenes/Dungeons/BeeHive.as
+++ b/classes/classes/Scenes/Dungeons/BeeHive.as
@@ -95,7 +95,9 @@ import classes.ItemType;
 			rooms.AddElement("B4",new DngRoom("B4", ""));
 			rooms.AddElement("A4", new DngRoom("A4", ""));
 			DngDirection.createDirection(DngDirection.DirS, rooms.GetElement("B4" ), rooms.GetElement("StairsDown"));
-			DngDirection.createDirection(DngDirection.DirS, rooms.GetElement("B4" ), rooms.GetElement("StairsDown"));
+			DngDirection.createDirection(DngDirection.DirE, rooms.GetElement("C3" ), rooms.GetElement("StairsDown"));
+			DngDirection.createDirection(DngDirection.DirE, rooms.GetElement("C2" ), rooms.GetElement("C3"));
+			DngDirection.createDirection(DngDirection.DirE, rooms.GetElement("C1" ), rooms.GetElement("C2"));
 			room = (rooms.GetElement("B4") as DngRoom);
 
 			stairDown = room = (rooms.GetElement("StairsDown") as DngRoom);
@@ -108,15 +110,17 @@ import classes.ItemType;
 			setFloors(_floors);
 		}
 		
-		private function encounterBee(Me:DngDirection):void {
+		private function encounterBee(Me:DngDirection):Boolean {
 			outputText("\nThere is a beegirl.");
 			startCombat(new BeeGirl());
 			doNext(playerMenu);
+			return true;
 		}
-		private function encounterBee2(Me:DngRoom):void {
+		private function encounterBee2(Me:DngRoom):Boolean {
 			outputText("\nThere is another beegirl.");
 			startCombat(new BeeGirl());
 			doNext(playerMenu);
+			return true;
 		}
 		private function hasItem(Me:DngDirection):Boolean {
 			if (!player.hasItem(ItemType.lookupItem("BeeHony"), 1))
@@ -127,12 +131,16 @@ import classes.ItemType;
 			return true;
 		}
 		//player falls down to 1.floor when entering the room
-		private function trapDoor(Me:DngDirection):void {
+		private function trapDoor(Me:DngDirection):Boolean {
 			outputText("\nYou crash down through the floor and find yourself back on the lowest level of the beehive.\n")
 			var floor1:DngFloor = this.allFloors()[0] as DngFloor;
 			var Room:DngRoom = floor1.getRoom(Me.roomB.name);
-			if (Room != null) this.teleport( floor1, Room);	//Todo and if not found??
-			//geht nicht doNext(curry(this.teleport, floor1, Room));	
+			if (Room != null) {
+				doNext(curry(this.teleport, floor1, Room)); //this.teleport( floor1, Room);	//Todo and if not found??
+				return true;
+			}
+			return false; 	
+			
 		}
 	}
 
diff --git a/classes/classes/Scenes/Dungeons/DngDirection.as b/classes/classes/Scenes/Dungeons/DngDirection.as
index 64373d5cc..2bf136fcf 100644
--- a/classes/classes/Scenes/Dungeons/DngDirection.as
+++ b/classes/classes/Scenes/Dungeons/DngDirection.as
@@ -23,22 +23,22 @@ package classes.Scenes.Dungeons
 		//returns the opposite direction f.e up-down
 		public static function inverseDirection(DirEnum:int):int {
 			switch(DirEnum) {
-				case 0: 
-					return 1;
+				case DirN: 
+					return DirS;
 					break;
-				case 1: 
-					return 0;
+				case DirS: 
+					return DirN;
 					break;
-				case 2: 
-					return 3;
-				case 3: 
-					return 2;
+				case DirE: 
+					return DirW;
+				case DirW: 
+					return DirE;
 					break;
-				case 4: 
-					return 5;
+				case StairDown: 
+					return StairUp;
 					break;
-				case 5: 
-					return 4;
+				case StairUp: 
+					return StairDown;
 					break;
 				default: 
 					break;
@@ -49,22 +49,22 @@ package classes.Scenes.Dungeons
 		public static function DirEnumToString(DirEnum:int):String {
 			var backLabel:String = "";
 			switch(DirEnum) {
-				case 0: 
+				case DirN: 
 					backLabel = "N";
 					break;
-				case 1: 
+				case DirS: 
 					backLabel = "S";
 					break;
-				case 2: 
+				case DirE: 
 					backLabel = "E";
 					break;
-				case 3: 
+				case DirW: 
 					backLabel = "W";
 					break;
-				case 4: 
+				case StairUp: 
 					backLabel = "Stair up";
 					break;
-				case 5: 
+				case StairDown: 
 					backLabel = "Stair down";
 					break;
 				default: 
@@ -73,17 +73,16 @@ package classes.Scenes.Dungeons
 			return backLabel;
 		}
 		//Enum for possible directions
-		public static const DirW:int = 3;
-		public static const DirE:int = 2;
-		public static const DirN:int = 0;
-		public static const DirS:int = 1;
-		public static const StairUp:int = 4;	
+		public static const DirW:int = 4;
+		public static const DirE:int = 3;
+		public static const DirN:int = 1;
+		public static const DirS:int = 2;
+		public static const StairUp:int = 6;	
 		public static const StairDown:int = 5;
 				
 		// default functions for callbacks
 		public static function FALSE(Me:DngDirection):Boolean { return false; };
 		public static function TRUE(Me:DngDirection):Boolean { return true; };
-		public static function NOP(Me:DngDirection):Boolean { return true; };
 		
 		public function DngDirection(DirEnum:int,Name:String,Description:String) 
 		{	
@@ -95,18 +94,21 @@ package classes.Scenes.Dungeons
 		/*public function onEnterAtoB():void { 
 			onEnterAtoBFct();
 		}*/
-		public function onEnter():void { 
-			onEnterFct(this);
+		public function onEnter():Boolean { 
+			if (onEnterFct == null) return false;
+			return onEnterFct(this);
 		}
 		//gets called when player  exits into this direction
 		/*public function onExitBtoA():void { 
 			onExitBtoAFct();
 		};*/
-		public function onExit():void { 
-			onExitFct(this);
+		public function onExit():Boolean { 
+			if (onExitFct == null) return false;
+			return onExitFct(this);
 		};
 		//function to check if player can use this direction; you should also set tooltip for display
 		public function canExit():Boolean { 
+			if (canExitFct == null) return true;
 			return canExitFct(this); 
 		}
 		/*public function canExitBtoA():Boolean { 
@@ -114,9 +116,9 @@ package classes.Scenes.Dungeons
 		}*/
 		
 		//public var onEnterAtoBFct:Function = NOP;
-		public var onExitFct:Function = NOP;
-		public var canExitFct:Function = TRUE;
-		public var onEnterFct:Function = NOP;
+		public var onExitFct:Function = null;
+		public var canExitFct:Function = null;
+		public var onEnterFct:Function = null;
 		//public var onExitBtoAFct:Function = NOP;
 		//public var canExitBtoAFct:Function = NOP;
 		private var Direction:int;
diff --git a/classes/classes/Scenes/Dungeons/DngFloor.as b/classes/classes/Scenes/Dungeons/DngFloor.as
index 5bd1bd96a..845e94a2d 100644
--- a/classes/classes/Scenes/Dungeons/DngFloor.as
+++ b/classes/classes/Scenes/Dungeons/DngFloor.as
@@ -5,6 +5,9 @@ package classes.Scenes.Dungeons
 	 * @author jk
 	 */
 	//a floor of the dungeon
+	//a floor consist of several rooms that are arranged in a xy-coordinate system
+	//every room is connected up to 4 surrounding rooms, + stairs to lower/higher floor; 
+	//
 	public class DngFloor {
 		private var rooms:/*DngRoom*/Array = [];	//list of rooms
 		public function addRoom(room:DngRoom):void { 
diff --git a/classes/classes/Scenes/Dungeons/DngMapper.as b/classes/classes/Scenes/Dungeons/DngMapper.as
index 9d921ddfd..5badf1e15 100644
--- a/classes/classes/Scenes/Dungeons/DngMapper.as
+++ b/classes/classes/Scenes/Dungeons/DngMapper.as
@@ -1,10 +1,12 @@
 package classes.Scenes.Dungeons 
 {
+	import flash.utils.Dictionary;
 	/**
 	 * ...
 	 * @author jk
 	 */
-	//builds the map from the dungeons info and actualRoom
+	// builds the map from the dungeons info and actualRoom
+	// it is expected that all rooms in a floor are somehow connected with each other - no isolated rooms !
 	
 	//Not completed !
 	public class DngMapper 
@@ -15,22 +17,132 @@ package classes.Scenes.Dungeons
 			
 		}
 		public var Dungeon:DungeonAbstractContent = null;
+		private var allinfo:Array;
+		private var maxX:int;
+		private var maxY:int;
+		private var minX:int;
+		private var minY:int;
+		private var floor:DngFloor;
 		
+		public function createMap(Floor:DngFloor):void {
+			floor = Floor;
+			var allrooms:Array = Floor.allRooms();
+			var allrooms2:Array = new Array(0);
+			allinfo = new Array(allrooms.length);
+			var dirs:Array;
+			var dir:DngDirection;
+			var room:DngRoom;
+			var room2:DngRoom;
+			var x:int;
+			var y:int;
+
+			var m:int;
+			
+			var roomInfo:DngMapperInfo = new DngMapperInfo();
+			var roomInfo2:DngMapperInfo ;
+			roomInfo.X = x = maxX = minX = 0;
+			roomInfo.Y = y = maxY = minY = 0;
+		/*  put 1.room of actual floor to dictionary, set coord XY ={0,0]
+		 *  get next room from dictionary until no more
+		 *  	for every direction of room
+		 * 			get targt room and place into dictionary
+		 * 			depending of direction, add flags to source & target room
+		 * 			calculate coord of target room  (f.e. direction =E then X/Y = {+1 , +0})
+		 * 		...
+		 *  ...
+		 */ 
+			allinfo[0] = roomInfo;
+			allrooms2[0] = 0;
+			for (var i:int = 0; i < allrooms.length; i++ ) {
+				m = (allrooms2[i] as int);
+				room = (allrooms[m] as DngRoom);
+				roomInfo = (allinfo[m] as DngMapperInfo);
+				dirs = room.getDirections();
+				for (var k:int=0; k < dirs.length; k++ ) {
+					if (dirs[k] == null) continue;
+					dir = dirs[k] as DngDirection;
+					room2 = dir.roomB;
+					roomInfo.Connect = roomInfo.Connect + (1 << dir.getDirEnum());
+					m = allrooms.indexOf(room2);
+					if (m >= 0) {
+						roomInfo2 = new DngMapperInfo();
+						switch (dir.getDirEnum()) {
+							case DngDirection.DirN: 
+								roomInfo2.X = roomInfo.X;
+								roomInfo2.Y = roomInfo.Y-1;
+								break;
+							case DngDirection.DirS: 
+								roomInfo2.X = roomInfo.X;
+								roomInfo2.Y = roomInfo.Y+1;
+								break;
+							case DngDirection.DirE: 
+								roomInfo2.X = roomInfo.X+1;
+								roomInfo2.Y = roomInfo.Y;
+								break;
+							case DngDirection.DirW: 
+								roomInfo2.X = roomInfo.X-1;
+								roomInfo2.Y = roomInfo.Y;
+								break;
+							default:
+								break;
+						}
+						if (roomInfo2.X < minX) minX = roomInfo2.X;
+						if (roomInfo2.X > maxX) maxX = roomInfo2.X;
+						if (roomInfo2.Y < minY) minY = roomInfo2.Y;
+						if (roomInfo2.Y > maxY) maxY = roomInfo2.Y;
+						
+						allinfo[m] = roomInfo2;
+						if(allrooms2.indexOf(m)<0) allrooms2.push(m);
+					}
+				}
+			}
+		/* now we have a dictonary of all rooms, their coordinate and flags
+		 * create 2DArray of size ( 2*(maxX-minX) , 2*(maxY-minY)) ; even indices store rooms "[ ]", uneven indices store directions " - "
+		 * for every room in dictionary
+		 * 		update Array[2*(X-minX)][2*(Y-minY)] with room-information
+		 * 		update Array[2*(X-1-minX)][2*(Y-0-minY)] with W-direction
+		 * 		update Array[2*(X-0-minX)][2*(Y-1-minY)] with N-direction
+		 * 		aso.
+		 * ...
+		*/
+
+
+		}
 		/*
-		 *  start with 1.room at coord XY =0,0
+		 * 
+		 * now we can print something like this:
+		 * 	[ ]-[ ]-[ ]-[S]
+		 *   |	 |	 |   |	
+		 *  [ ]-[P]-[ ]-[ ]
 		*/
-		public function printMap():void {
-			rawOutputText(Dungeon.name);
-			if (DungeonAbstractContent.dungeonLoc == 68) {
-				rawOutputText(", Floor 1");
-				rawOutputText("\n        [ ]    ");
-				rawOutputText("\n |       |     ");
-				rawOutputText("\n[ ]-[ ]-[ ]    ");
-				rawOutputText("\n     |       | ");
-				rawOutputText("\n    [ ]-[ ]-[ ]");
-				rawOutputText("\n     |       | ");
-				rawOutputText("\n[P]-[ ]     [S]");
+		public function printMap():String {
+			//Todo update player location
+			var _line:String ="";
+			var map:Array;
+			var roomInfo:DngMapperInfo;
+			var i:int;
+			map = new Array(2*(maxX - minX)+1); 
+			for (i = 0; i < map.length; i++) {  
+				var submap:Array = new Array(2*(maxY - minY)+1); 
+				for (var j:int = 0; j < submap.length; j++) {   
+					submap[j] = "   ";   
+				}
+				map[i] = submap;
+			}
+			for (i = 0; i < allinfo.length; i++ ) {
+				if (allinfo[i] == null) continue;
+				roomInfo = allinfo[i] as DngMapperInfo;
+				map[2*(roomInfo.X-minX)][2*(roomInfo.Y-minY)] = roomInfo.Connect.toString();
+			}
+			
+			_line += (/*Dungeon.name + " " +*/ floor.name +"\n");
+			for (i = 0; i < (2*(maxX - minX)+1); i++) {  
+				for (var j:int = 0; j < (2*(maxY - minY)+1); j++) {   
+					_line += map[i][j];   
+				}
+				_line += "\n";
 			}
+			return _line;
 		}
 	}
 
diff --git a/classes/classes/Scenes/Dungeons/DngMapperInfo.as b/classes/classes/Scenes/Dungeons/DngMapperInfo.as
new file mode 100644
index 000000000..8022780e2
--- /dev/null
+++ b/classes/classes/Scenes/Dungeons/DngMapperInfo.as
@@ -0,0 +1,24 @@
+package classes.Scenes.Dungeons 
+{
+	/**
+	 * ...
+	 * @author jk
+	 *
+	 */
+	// a helper class to store info for a room
+	public class DngMapperInfo 
+	{
+		
+		public function DngMapperInfo() 
+		{
+			
+		}
+		public var X:int = 0;
+		public var Y:int = 0;
+		public var Hidden:Boolean = false;
+		public var Connect:int = 0;
+		
+		
+	}
+
+}
\ No newline at end of file
diff --git a/classes/classes/Scenes/Dungeons/DngRoom.as b/classes/classes/Scenes/Dungeons/DngRoom.as
index f2281b371..03e062e41 100644
--- a/classes/classes/Scenes/Dungeons/DngRoom.as
+++ b/classes/classes/Scenes/Dungeons/DngRoom.as
@@ -12,48 +12,81 @@ package classes.Scenes.Dungeons
 			name = Name;
 			description = Description=="" ? Name:Description;
 		}
-		public static function NOP(Me:DngRoom):Boolean { return true; };
+
 		public var isDungeonExit:Boolean = false; // player can leave to camp with Leave-button
 		public var isDungeonEntry:Boolean = false; //when entering the dungeon player will be coming from here; there should only be one of this 
 		private var directions:/*DngDirection*/Array = new Array(null, null, null, null, null, null);	//list of directions
 		private var operations:/*DngOperations*/Array = []; //list of additional operations (= buttons you can press)
 
 		public function setDirection(DirEnum:int, direction:DngDirection):void { 
-			directions.splice(DirEnum,1,direction);
+			directions.splice(DirEnum-1,1,direction);
 		};
 		public function getDirections():Array {
 			return directions;
 		}
 		public function getDirection(DirEnum:int):DngDirection {
-			return directions[DirEnum] as DngDirection;
+			return directions[DirEnum-1] as DngDirection;
 		}
 		//this is called after the direction onEnter-Event was called
-		public function onEnter():void { 
-			onEnterFct(this);
+		public function onEnter():Boolean { 
+			if (onEnterFct == null) return false;
+			return onEnterFct(this);
 		}
-		public var onEnterFct:Function = NOP;
+		public var onEnterFct:Function = null;
 		
 		public function moveHere(from:DngRoom):void {
+			origResumeFct = DungeonAbstractContent.inRoomedDungeonResume;
+			fromRoom = from;
+			it = 0;
+			moveIterator();
+		}
+		private var origResumeFct:Function = null;
+		private var it:int;
+		private var fromRoom:DngRoom;
+		// Whats that good for: onExit or onEnter might trigger an interaction/combat that we have to finish first befor displaying navigation buttons again.
+		// iterator->onExit->startCombat->won->doNext(resume)->iterator
+		private function moveIterator():void {
 			var dir:DngDirection;
+			var _it:int = 0;
 			//call Exit function from previous room
-			for each (var element:* in from.getDirections() ) {
-				if (element == null) continue;
+			for each (var element:* in fromRoom.getDirections() ) {
+				_it = _it +1; 
+				if (element == null ) continue;
+				if (_it <= it) continue;
+				it = _it;
 				dir = element as DngDirection;
-				if (dir.roomA == from && dir.roomB==this) {
-					dir.onExit(); 
-				}/*else if (dir.roomB == from) {
-					dir.onExitBtoA();
-				}*/
+				if (dir.roomA == fromRoom && dir.roomB==this) {
+					if (dir.onExit())
+					{
+						DungeonAbstractContent.inRoomedDungeonResume = this.moveIterator
+						return;
+					}
+				}
 			}
 			//call Entry function of this room
 			for each (var element1:* in this.getDirections() ) {
+				_it = _it +1; 
 				if (element1 == null) continue;
+				if (_it <= it) continue;
+				it = _it;
 				dir = element1 as DngDirection;
-				if (dir.roomA==this && dir.roomB == from) {
-					dir.onEnter();
+				if (dir.roomA==this && dir.roomB == fromRoom) {
+					if (dir.onEnter()) {
+						DungeonAbstractContent.inRoomedDungeonResume = this.moveIterator
+						return;
+					}
 				}
 			}
-			if(from != this && !CoC.instance.inCombat) onEnter();  //Todo if there was combat started in direction.onEnter, room.onEnter should be called after ombat done
+			_it = _it +1; 
+			if (_it > it && onEnter()) {
+				it = _it;
+				DungeonAbstractContent.inRoomedDungeonResume = this.moveIterator
+				return;
+			}
+			
+			DungeonAbstractContent.inRoomedDungeonResume = origResumeFct;
+			DungeonAbstractContent.inRoomedDungeonResume();
+		
 		}
 		public var description:String = ""; 
 		public var isHidden:Boolean = false;	//the room and directions to it will not be dislayed on the map unless the player visited it once
diff --git a/classes/classes/Scenes/Dungeons/DungeonAbstractContent.as b/classes/classes/Scenes/Dungeons/DungeonAbstractContent.as
index 5efeb8aba..7c7fd1529 100644
--- a/classes/classes/Scenes/Dungeons/DungeonAbstractContent.as
+++ b/classes/classes/Scenes/Dungeons/DungeonAbstractContent.as
@@ -33,8 +33,10 @@ import classes.Scenes.SceneLib;
 		public function allFloors():Array {
 			return floors;
 		}
+		private var Mapper:DngMapper; 
 		//enters the dungeon; also does some checks to verify that dungeon was properly setup
 		public function enterDungeon_():void {
+			Mapper = new DngMapper();
 			actualRoom = null;
 			var Entry:DngRoom = null;
 			var Exit:DngRoom = null;
@@ -56,13 +58,13 @@ import classes.Scenes.SceneLib;
 			dungeonLoc = -1; // not oldschool dungeon
 			inDungeon = false;
 			inRoomedDungeon = true;
-			inRoomedDungeonResume = resumeRoom;
+			
 			moveToRoom(Entry);
 			playerMenu();
 			
 		}
 		
-		public function teleport(Floor:DngFloor, Room:DngRoom) {
+		public function teleport(Floor:DngFloor, Room:DngRoom):void {
 			actualRoom = null;
 			moveToRoom(Room);
 		}
@@ -73,6 +75,7 @@ import classes.Scenes.SceneLib;
 		
 		private function moveToRoom(newRoom:DngRoom):void {
 			clearOutput();
+			cheatTime(1 / 12);
 			statScreenRefresh();
 			//DungeonCore.setTopButtons();
 			spriteSelect(-1);
@@ -81,9 +84,12 @@ import classes.Scenes.SceneLib;
 			actualRoom = newRoom;
 			if (_actualRoom != null) {
 				newRoom.moveHere(_actualRoom); //this will trigger onExit/onEnter
+			} else {
+				inRoomedDungeonResume = resumeRoom;
+				inRoomedDungeonResume();
 			}
 
-			if(!CoC.instance.inCombat) resumeRoom(); //resume after combat done
+			//if(!CoC.instance.inCombat) resumeRoom(); //resume after combat done
 		}
 		private function resumeRoom():void {
 			clearOutput();
@@ -96,8 +102,8 @@ import classes.Scenes.SceneLib;
 			
 			/*		Menu Layout
 			 * 		[ Op1 ]	[ Op2 ]	[ Op3 ]	[ Op4 ]	[More ]
-			 * 		[ Up  ]	[  N  ]	[Down ]	[Mast ]	[ Map ]
-			 * 		[  W  ]	[  S  ]	[  E  ]	[ Inv ]	[     ]
+			 * 		[ Up  ]	[  N  ]	[Down ]	[Mast ]	[     ]
+			 * 		[  W  ]	[  S  ]	[  E  ]	[ Inv ]	[ Map ]
 			 *  
 			 */
 			var bt:int;
@@ -121,7 +127,7 @@ import classes.Scenes.SceneLib;
 			});
             if (player.lust >= 30) addButton(8, "Masturbate", SceneLib.masturbation.masturbateGo);
             addButton(13, "Inventory", inventory.inventoryMenu).hint("The inventory allows you to use an item.  Be careful as this leaves you open to a counterattack when in combat.");
-			//addButton(14, "Map", map.displayMap).hint("View the map of this dungeon.");
+			addButton(14, "Map", displayMap).hint("View the map of this dungeon.");
 			if(actualRoom.isDungeonExit) {
 				for (var i:int = 5; i < 15; i++ ) {	//find an empty navigation button for leave
 					bt = i;
@@ -130,6 +136,11 @@ import classes.Scenes.SceneLib;
 				addButton(bt, "Leave", exitDungeon_, false);
 			}
 		}
+		private function displayMap():void {
+			Mapper.createMap(this.floors[0]); //Todo
+			rawOutputText( this.name + "\n"+ Mapper.printMap());
+			doNext(resumeRoom);
+		}
 		public function exitDungeon_(byDefeat:Boolean):void {
 			clearOutput();
 			if (byDefeat) {
-- 
2.17.1.windows.2

